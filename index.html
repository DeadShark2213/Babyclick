Got it — I updated the single-file index.html with:
- Slower player (reduced accel, max speed, jump, dash)
- Rolling uses realistic rotation (angle changes by -distance / radius)
- Slower parallax and moving-platform motion
- Full level (~0 → 4800px) with many platforms, moving platforms, coins and a finish flag
- Level complete overlay and restart (R)

Paste the following into your project (replace your existing index.html):

```html
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Red Ball Platformer - Full Level</title>
<style>
  html,body { height:100%; margin:0; background:#87CEEB; font-family:Arial,Helvetica,sans-serif; }
  #gameCanvas { display:block; background: linear-gradient(#87CEEB, #bfe9ff); width:100%; height:100vh; }
  /* Simple overlay for buttons on mobile */
  .touch-controls {
    position: absolute; left:0; right:0; bottom:16px; pointer-events:none;
    display:flex; justify-content:space-between; padding:0 16px;
  }
  .touch-group { pointer-events:auto; display:flex; gap:8px; align-items:center; }
  .touch-btn {
    width:64px; height:64px; border-radius:12px; background:rgba(255,255,255,0.18);
    display:flex; justify-content:center; align-items:center; color:white; font-weight:bold;
    backdrop-filter: blur(4px); user-select:none;
  }
  .hud {
    position:absolute; left:12px; top:12px; color:#222; text-shadow: 0 1px 0 rgba(255,255,255,0.6);
    background: rgba(255,255,255,0.6); padding:6px 10px; border-radius:8px; font-weight:bold;
  }
  .hint { position:absolute; right:12px; top:12px; color:#222; background:rgba(255,255,255,0.6);
    padding:6px 10px; border-radius:8px; font-size:13px;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div class="hud" id="hud">Score: 0</div>
<div class="hint">W/↑/Space jump • A/D ←/→ move • Shift dash • P pause • R restart</div>

<!-- Touch controls -->
<div class="touch-controls" id="touchControls" style="display:none;">
  <div class="touch-group">
    <div class="touch-btn" id="leftBtn">◀</div>
    <div class="touch-btn" id="rightBtn">▶</div>
  </div>
  <div class="touch-group">
    <div class="touch-btn" id="jumpBtn">⬆</div>
  </div>
</div>

<script>
/*
Red Ball Platformer - updated: slower ball, slower animation, full level
Tweak constants below.
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;

// Physics & player constants (tuned slower)
const GRAVITY = 1800;          // px/s^2
const FRICTION_GROUND = 0.88;  // per second approximation (applied manually)
const AIR_DRAG = 0.996;
const MOVE_ACCEL = 1400;       // px/s^2 (reduced)
const MAX_SPEED = 280;         // px/s (slower)
const JUMP_VELOCITY = 640;     // px/s (slightly reduced)
const DASH_VELOCITY = 700;     // px/s applied instantly (reduced)
const DASH_COOLDOWN = 0.8;     // seconds
const PLAYER_RADIUS = 28;

// World dimensions
const WORLD_WIDTH = 4800;
const WORLD_HEIGHT = 2000;

let lastTime = performance.now()/1000;
let paused = false;
let score = 0;
let levelComplete = false;

// Camera
const camera = { x:0, y:0, w:W, h:H };

// Input state
const keys = {};
let touchState = { left:false, right:false, jump:false };

// Player
const player = {
  x: 160,
  y: 300,
  vx: 0,
  vy: 0,
  r: PLAYER_RADIUS,
  onGround: false,
  jumpsLeft: 2,
  angle: 0,
  canDash: true,
  lastDash: -999
};

// Full-level platforms (spaced across world)
const platforms = [
  { x: -2000, y: 520, w: 10000, h: 48, vx:0, vy:0, type:'static' }, // ground (spans well beyond level)
  { x: 320, y: 420, w: 220, h: 22, vx:0, vy:0 },
  { x: 720, y: 340, w: 160, h: 22, vx:0, vy:0 },
  { x: 980, y: 280, w: 180, h: 22, vx:-50, vy:0, type:'moving', rangeX:120 },
  { x: 1320, y: 220, w: 140, h: 22, vx:0, vy:0 },
  { x: 1580, y: 380, w: 260, h: 22, vx:0, vy:0 },
  { x: 1900, y: 320, w: 220, h: 22, vx:0, vy:0 },
  { x: 2200, y: 260, w: 160, h: 22, vx:0, vy:0 },
  { x: 2450, y: 340, w: 200, h: 22, vx:60, vy:0, type:'moving', rangeX:140 },
  { x: 2780, y: 300, w: 180, h: 22, vx:0, vy:0 },
  { x: 3100, y: 250, w: 160, h: 22, vx:-40, vy:0, type:'moving', rangeX:100 },
  { x: 3400, y: 360, w: 260, h: 22, vx:0, vy:0 },
  { x: 3720, y: 300, w: 180, h: 22, vx:0, vy:0 },
  { x: 4020, y: 240, w: 160, h: 22, vx:0, vy:0 },
  { x: 4320, y: 340, w: 220, h: 22, vx:0, vy:0 },
  { x: 4600, y: 300, w: 300, h: 22, vx:0, vy:0 }
];

// keep original positions for moving platforms
platforms.forEach(p => { p.ox = p.x; p.oy = p.y; });

// Collectibles
const coins = [];
function makeCoins() {
  coins.length = 0;
  const pos = [
    [420,380],[760,300],[1030,240],[1320,180],[1600,340],[1970,280],
    [2100,220],[2360,300],[2600,260],[2890,220],[3200,200],[3480,320],
    [3680,260],[3950,220],[4200,300],[4500,260]
  ];
  for (const p of pos) coins.push({ x:p[0], y:p[1], r:10, collected:false });
}
makeCoins();

// Finish flag
const flag = { x: WORLD_WIDTH - 200, y: 160, w: 16, h: 160, reached:false };

// Resize handling
function onResize() {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  camera.w = W; camera.h = H;
}
addEventListener('resize', onResize);

// Input handling
addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'KeyP') paused = !paused;
  if (e.code === 'KeyR') resetGame();
  // prevent space arrow scrolling
  if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
});
addEventListener('keyup', e => { keys[e.code] = false; });

function isLeft() {
  return keys['KeyA'] || keys['ArrowLeft'] || touchState.left;
}
function isRight() {
  return keys['KeyD'] || keys['ArrowRight'] || touchState.right;
}
function pressJump() {
  return keys['KeyW'] || keys['Space'] || keys['ArrowUp'] || touchState.jump;
}

// Touch controls UI
const tControls = document.getElementById('touchControls');
function setupTouchControls() {
  if ('ontouchstart' in window || innerWidth < 900) tControls.style.display = 'flex';
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const jumpBtn = document.getElementById('jumpBtn');

  function bindTouch(el, start, end) {
    el.addEventListener('touchstart', e => { start(); e.preventDefault(); }, {passive:false});
    el.addEventListener('touchend', e => { end(); e.preventDefault(); }, {passive:false});
    el.addEventListener('mousedown', e => { start(); e.preventDefault(); });
    el.addEventListener('mouseup', e => { end(); e.preventDefault(); });
    el.addEventListener('mouseleave', e => { end(); });
  }

  bindTouch(leftBtn, () => touchState.left = true, () => touchState.left = false);
  bindTouch(rightBtn, () => touchState.right = true, () => touchState.right = false);
  bindTouch(jumpBtn, () => {
    touchState.jump = true;
    setTimeout(()=> touchState.jump = false, 150);
  }, () => {});
}
setupTouchControls();

// Collision helpers: circle vs rect
function circleRectCollision(cx, cy, r, rx, ry, rw, rh) {
  const closestX = Math.max(rx, Math.min(cx, rx + rw));
  const closestY = Math.max(ry, Math.min(cy, ry + rh));
  const dx = cx - closestX;
  const dy = cy - closestY;
  return { hit: dx*dx + dy*dy <= r*r, dx, dy, closestX, closestY };
}

function update(dt) {
  if (paused) return;
  if (levelComplete) return;

  // controls
  let move = 0;
  if (isLeft()) move -= 1;
  if (isRight()) move += 1;

  // horizontal acceleration
  player.vx += move * MOVE_ACCEL * dt;

  // limit speed
  if (player.vx > MAX_SPEED) player.vx = MAX_SPEED;
  if (player.vx < -MAX_SPEED) player.vx = -MAX_SPEED;

  // dash (Shift)
  if ((keys['ShiftLeft'] || keys['ShiftRight']) && player.canDash && (performance.now()/1000 - player.lastDash) > 0.01) {
    const dir = (move !== 0) ? Math.sign(move) : (player.vx === 0 ? 1 : Math.sign(player.vx));
    player.vx = dir * DASH_VELOCITY;
    player.lastDash = performance.now()/1000;
    player.canDash = false;
    setTimeout(()=> player.canDash = true, DASH_COOLDOWN * 1000);
  }

  // gravity
  player.vy += GRAVITY * dt;

  // apply drag
  if (player.onGround) {
    player.vx *= Math.pow(FRICTION_GROUND, dt*60/16);
  } else {
    player.vx *= AIR_DRAG;
  }

  // jumping (double jump)
  if (pressJump() && !player._jumpPressedLast) {
    if (player.jumpsLeft > 0) {
      player.vy = -JUMP_VELOCITY;
      player.jumpsLeft--;
      player.onGround = false;
    }
  }
  player._jumpPressedLast = pressJump();

  // integrate
  const oldX = player.x;
  player.x += player.vx * dt;
  player.y += player.vy * dt;

  // world bounds (fall)
  if (player.y > WORLD_HEIGHT + 200) resetPlayer();

  // platforms movement update (slower motion)
  platforms.forEach(p => {
    if (p.type === 'moving') {
      p.x = p.ox + Math.sin(performance.now()/1000 * 0.7) * (p.rangeX || 80);
    }
  });

  // collision detection / resolution
  player.onGround = false;
  for (const p of platforms) {
    const c = circleRectCollision(player.x, player.y, player.r, p.x, p.y, p.w, p.h);
    if (c.hit) {
      const overlapX = player.r - Math.abs(c.dx);
      const overlapY = player.r - Math.abs(c.dy);

      if (overlapY < overlapX) {
        // vertical
        if (player.y < p.y) {
          // landed on top
          player.y = p.y - player.r;
          player.vy = 0;
          player.onGround = true;
          player.jumpsLeft = 2;
        } else {
          // hit from below
          player.y = p.y + p.h + player.r + 0.1;
          player.vy = Math.max(0, player.vy);
        }
      } else {
        // horizontal resolution
        if (player.x < p.x) {
          player.x = p.x - player.r - 0.1;
        } else {
          player.x = p.x + p.w + player.r + 0.1;
        }
        player.vx = 0;
      }
    }
  }

  // coin collection
  for (const coin of coins) {
    if (coin.collected) continue;
    const dx = player.x - coin.x;
    const dy = player.y - coin.y;
    if (dx*dx + dy*dy < (player.r + coin.r)*(player.r + coin.r)) {
      coin.collected = true;
      score += 1;
      document.getElementById('hud').textContent = 'Score: ' + score;
    }
  }

  // realistic rolling: angle change based on distance traveled
  const dist = player.x - oldX;
  player.angle += -dist / Math.max(1, player.r);

  // camera follow (smooth)
  const targetCamX = player.x - W/2;
  const targetCamY = player.y - H/2;
  camera.x += (targetCamX - camera.x) * Math.min(1, 6*dt);
  camera.y += (targetCamY - camera.y) * Math.min(1, 6*dt);

  // clamp camera to world bounds
  camera.x = Math.max(0, Math.min(camera.x, WORLD_WIDTH - W));
  camera.y = Math.max(-500, Math.min(camera.y, WORLD_HEIGHT - H + 500));

  // check finish flag
  if (!flag.reached && player.x > flag.x - 40 && player.y < flag.y + flag.h) {
    flag.reached = true;
    levelComplete = true;
    paused = true;
  }
}

function draw() {
  ctx.clearRect(0,0,W,H);

  // scene transform
  ctx.save();
  ctx.translate(-Math.round(camera.x), -Math.round(camera.y));

  drawBackground();

  // platforms
  for (const p of platforms) drawPlatform(p);

  // coins
  for (const c of coins) if (!c.collected) drawCoin(c);

  // finish flag
  drawFlag(flag);

  // player
  drawPlayer(player);

  ctx.restore();

  // overlays
  if (paused && !levelComplete) {
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = 'white';
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PAUSED', W/2, H/2);
  }

  if (levelComplete) {
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = 'white';
    ctx.font = 'bold 44px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('LEVEL COMPLETE', W/2, H/2 - 20);
    ctx.font = '20px Arial';
    ctx.fillText('Press R to restart', W/2, H/2 + 20);
  }
}

// Draw helpers
function drawBackground() {
  const baseY = 640;
  ctx.save();
  ctx.fillStyle = '#7ec850';
  for (let i=-2;i<10;i++) {
    const hx = i * 700 - (camera.x*0.12 % 700);
    const hy = baseY + Math.sin(i*0.6 + performance.now()/3500)*18;
    ctx.beginPath();
    ctx.ellipse(hx, hy, 500, 160, 0, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

function drawPlatform(p) {
  ctx.save();
  ctx.fillStyle = '#5b3a2e';
  ctx.fillRect(p.x, p.y, p.w, p.h);
  ctx.fillStyle = '#7b523f';
  ctx.fillRect(p.x, p.y, p.w, Math.min(6, p.h));
  ctx.restore();
}

function drawCoin(c) {
  ctx.save();
  ctx.translate(c.x, c.y);
  ctx.fillStyle = 'gold';
  ctx.beginPath();
  ctx.ellipse(0,0,c.r,c.r*0.9,0,0,Math.PI*2);
  ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.beginPath();
  ctx.ellipse(-c.r*0.35, -c.r*0.35, c.r*0.35, c.r*0.25, 0,0,Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function drawFlag(f) {
  ctx.save();
  ctx.fillStyle = '#333';
  ctx.fillRect(f.x, f.y, 6, f.h);
  ctx.fillStyle = f.reached ? '#66bb6a' : '#ef5350';
  ctx.beginPath();
  ctx.moveTo(f.x + 6, f.y + 12);
  ctx.lineTo(f.x + 6 + 80, f.y + 36);
  ctx.lineTo(f.x + 6, f.y + 60);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawPlayer(p) {
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(p.angle);

  // body
  ctx.beginPath();
  ctx.fillStyle = '#e53935';
  ctx.arc(0, 0, p.r, 0, Math.PI*2);
  ctx.fill();

  // subtle shading
  const grad = ctx.createRadialGradient(-p.r*0.3, -p.r*0.5, p.r*0.1, 0,0,p.r);
  grad.addColorStop(0, 'rgba(255,255,255,0.45)');
  grad.addColorStop(0.5, 'rgba(255,255,255,0.05)');
  grad.addColorStop(1, 'rgba(0,0,0,0.15)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(-p.r*0.3, -p.r*0.5, p.r*0.9, 0, Math.PI*2);
  ctx.fill();

  // face
  ctx.fillStyle = 'white';
  const eyeY = -6;
  const eyeX = 8;
  ctx.beginPath(); ctx.ellipse(-eyeX, eyeY, 6, 8, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(eyeX, eyeY, 6, 8, 0, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#222';
  ctx.beginPath(); ctx.arc(-eyeX, eyeY, 3.2, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(eyeX, eyeY, 3.2, 0, Math.PI*2); ctx.fill();

  // eyebrows
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(-eyeX-6, eyeY-10); ctx.quadraticCurveTo(-eyeX, eyeY-14, -eyeX+6, eyeY-10); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(eyeX-6, eyeY-10); ctx.quadraticCurveTo(eyeX, eyeY-14, eyeX+6, eyeY-10); ctx.stroke();

  // mouth
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(0, 6, 10, 0.15*Math.PI, 0.85*Math.PI);
  ctx.stroke();

  ctx.restore();
}

function loop() {
  const now = performance.now()/1000;
  const dt = Math.min(0.033, now - lastTime);
  lastTime = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

function resetPlayer() {
  player.x = 160; player.y = 300; player.vx = 0; player.vy = 0; player.angle = 0;
  player.jumpsLeft = 2; player.canDash = true;
}

function resetGame() {
  score = 0;
  levelComplete = false;
  paused = false;
  flag.reached = false;
  makeCoins();
  document.getElementById('hud').textContent = 'Score: 0';
  resetPlayer();
}

// initialize
resetGame();
requestAnimationFrame(loop);

// debug
window.game = { player, platforms, coins, flag, resetGame };
</script>
</body>
</html>
```

